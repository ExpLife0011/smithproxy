settings = {
    certs_path = "/etc/smithproxy/certs/default/";
    certs_ca_key_password = "smithproxy";
    certs_ca_path = "/etc/smithproxy/certs/ca/default/";

    plaintext_port = "50080";   // beware, it's a string!
    plaintext_workers = 0;      // 0 = default setting -- use number of CPU threading cores detected by STL

    ssl_port = "50443";         // beware, it's a string!
    ssl_workers = 0;
    ssl_autodetect = TRUE;         //enable/disable scanning of the plaintext protocols and inspect if SSL is detected
    ssl_autodetect_harder = TRUE;  //enable/disable retries to detect SSL -- final timeout is 12.5ms, then the traffic is definitely passed.
                                   //it's by default true, but it's effective only when ssl_autodetect is set too.
                                   //if set, beware that connections will be blocked for a while, similarly as the worker too.
                                   //Suggestion: raise plaintext_workers.
    
    udp_port = "50081";         // beware, it's a string!
    udp_workers = 0;
    
    socks_workers = 0;          // 0 = default setting, -1 = don't run  -- use number of CPU threading cores detected by STL
    
    default_write_payload = FALSE; // write payload into files by default (policy rules will override this)
    write_payload_dir = "/var/local/smithproxy/data";
    write_payload_file_prefix = "";
    write_payload_file_suffix = "smcap";

/*
    Logging levels 
    NON 0   INF 6
    FAT 1   DIA 7
    CRI 2   DEB 8
    ERR 3   DUM 9
    WAR 4   EXT 10
    NOT 5    
*/
    log_level = 6;              // INF
    log_file = "/var/log/smithproxy.log";   // comment this line out if you don't want to log in the file
    log_console = TRUE;                     // if log_file specified, you can control if log should be written 
                                            // additionally to stdout
    cli = {
        port = "50000";
        enable_password = "";
    }
    auth_portal = {                          // WARNING: active authentication will not work without detect profile and some signatures (min www/get|post)!
        address    = "192.168.254.1";        // when authentication portal should be displayed, redirect will go here (where webfr.py listens)
        http_port  = "8008";                 // which port webfr.py listens on
        https_port = "8043";                 // which port ssl webfr.py listens on
        ssl_key    = "portal-key.pem";	     // relative to settings.certs_path
        ssl_cert   = "portal-cert.pem";      // relative to settings.certs_path
    }
    web_rating = {
        // wot is not yet implemented
        wot_key = "57a92fd16754f60359c4d7fb6dd8b5ea7a26039f";  //this is only example API key which will NOT work.
    }
}

debug = {
    log_data_crc = FALSE;
    log_sockets  = FALSE;
    log_online_cx_name = FALSE;             // This could have heavy impact on performance, but will resolve CX name again 
                                            // whenever log is generated
    log_srclines = FALSE;                   // if message level is >= DIA, should we write source and line number?
    log_srclines_always = FALSE;            // should we write source and line number (overrides the above)?
    
    // Logging overrides table:
    // logging facility log_level will be overriden for specified module, if it's higher than general log level.
    log = {
         //sslcom = 6;
         //sslmitmcom = 6;
         //sslcertstore = 6;
         //proxy = 6;
         //mtrace = FALSE;
         alg_dns = FALSE;
    }
}

address_objects = {
    any = {
        type = 0;
        cidr = "0.0.0.0/0";
    }
}

port_objects = {
    all = {
        start = 0;
        end = 65535;
    }
    dns = {
        start = 53;
        end = 43;
    }
}

/*
 ICMP = 1
 TCP  = 6
 UDP  = 17
*/

proto_objects = {
    tcp = {
        id = 6;
    }
    udp = {
        id = 17;
    }
}

/*
 Detection modes:
 0 - NONE - no detection at all
 1 - PRE  - detect based on peeked data (not read yet, or salvaged data from read buffer, if read process was faster) and write buffer data (not written yet)
 2 - POST - detect based on received/sent data -- no reason to set it - useful for connections when peek doesn't seem to be reliable or generally doesn't work.
*/

detection_profiles = {
    default = {
        mode = 0;
    }
    detect = {
        mode = 1;
    }
}

content_profiles = {
    default = {
        write_payload = FALSE;
        write_limit_client = 0;
        write_limit_server = 0;
    }
}

// this is not yet implemented
tls_ca = {
    default = {
      path = "/etc/smithproxy/certs/ca/default/";
    }
}

tls_profiles = {
    default = {
        inspect = TRUE;
        use_pfs = TRUE;     // enable/disable DHE and ECDHE (perfect forward secrecy)
        allow_untrusted_issuers = FALSE;
        allow_invalid_certs = FALSE;
        allow_self_signed = FALSE;
        //ca_list = "default"; // not yet implemented
        ocsp_stapling = "TRUE";
        ocsp_stapling_mode = 0; // possible values: 
                                      // 0 = loose - if response is present - check. All connections are allowed, but complain in log if OCSP is missing, or is not verified.
                                      // 1 = strict - if response is present - check, don't allow unverified connections. Connections without OCSP response will be logged, but allowed.
                                      // 2 = require - require all connections to reply with OCSP stapling + be strict. This is dangerous and is only good for special purposes.
    }
    bypass = {
        inspect = FALSE;
    }
}

auth_profiles = {
    login = {
        authenticate = TRUE;
        resolve = TRUE;
    }
    resolve = {
        authenticate = FALSE;
        resolve = TRUE;
    }
}


alg_dns_profiles = {
    dns_default = {
        match_request_id = TRUE;
        randomize_id = FALSE;
    }
}

/*
    NAT valid values are: "none" "auto" to be added in future: "<address_objects>:[<port_objects>]"
*/
policy = (
    {
        proto = "udp";
        src = "any";
        sport = "all";
        dst = "any";
        dport = "dns";
        tls_profile = "default";
        detection_profile = "default";
        content_profile = "default";
        auth_profile = "resolve";
        action = "accept";
        nat = "none";
    },
    {
        proto = "tcp";
        src = "any";
        sport = "all";
        dst = "any";
        dport = "all";
        tls_profile = "default";
        detection_profile = "detect";
        content_profile = "default";
        auth_profile = "login";
        alg_dns_profile = "dns_default";
        action = "accept";
        nat = "none";
    }
)


starttls_signatures = (
    {
        cat  = "mail";
        name = "smtp/starttls";
        side = "client";
        flow = (
            {
                side = "r";
                type = "regex";
                signature = "^STARTTLS";
                bytes_start = 0;
                bytes_max = 16;
            },
            {
                side = "w";
                type = "regex";
                signature = "^2[0-5]0 ";
                bytes_start = 0;
                bytes_max = 16;
            }
        )
    },
    {
        cat  = "mail";
        name = "imap/starttls";
        side = "client";
        flow = (
            {
                side = "r";
                type = "regex";
                signature = ". STARTTLS\r\n";
                bytes_start = 0;
                bytes_max = 16;
            },
            {
                side = "w";
                type = "regex";
                signature = ". OK";
                bytes_start = 0;
                bytes_max = 64;
            }
        )
    },
    {
        cat  = "mail";    
        name = "pop3/starttls";
        side = "client";
        flow = (
            {
                side = "r";
                type = "regex";
                signature = "^STLS\r\n";
                bytes_start = 0;
                bytes_max = 10;
            },
            {
                side = "w";
                type = "regex";
                signature = "^[+]OK";
                bytes_start = 0;
                bytes_max = 15;
            }
        )
    },
    {
        cat  = "file";
        name = "ftp/starttls";
        side = "client";
        flow = (
            {
                side = "r";
                type = "regex";
                signature = "^AUTH TLS\r\n";
                bytes_start = 0;
                bytes_max = 10;
            },
            {
                side = "w";
                type = "regex";
                signature = "^[2][0-9][0-9] AUTH";
                bytes_start = 0;
                bytes_max = 15;
            }
        )
    },
    {
        cat  = "im";    
        name = "xmpp/starttls";
        side = "client";
        flow = (
            {
                side = "r";
                type = "regex";
                signature = "^<starttls [^>/]+xmpp-tls[^>/]/>";
                bytes_start = 0;
                bytes_max = 64;
            },
            {
                side = "w";
                type = "regex";
                signature = "^<proceed [^>/]+xmpp-tls[^>/]/>";
                bytes_start = 0;
                bytes_max = 64;
            }
        )
    }    
)

detection_signatures = (
    {
        cat  = "www";    
        name = "http/get|post";
        side = "client";
        flow = (
            {
                side = "r";
                type = "regex";
                signature = "^(GET|POST) +([^ \r\n]+)[^\r]+\r\n";
                bytes_start = 0;
                bytes_max = 200;
            }
        )
    },
    {
        cat  = "www";    
        name = "http/get|post+reply";
        side = "client";
        flow = (
            {
                side = "r";
                type = "regex";
                signature = "^(GET|POST) +([^ \r\n]+)";
                bytes_start = 0;
                bytes_max = 64;
            },
            {
                side = "w";
                type = "regex";
                signature = "HTTP/1.[01] +([1-5][0-9][0-9]) ";
                bytes_start = 0;
                bytes_max = 64;
            }
        )
    },
    {
        cat  = "av";
        name = "virus/eicar";
        side = "client";
        flow = (
            {
                side = "w";
                type = "simple";
                signature = "X5O!P%@AP[4\\PZX54(P^)7CC)7}$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H*";
                bytes_start = 0;
                bytes_max = 0;
            }
        )
    }    
)
